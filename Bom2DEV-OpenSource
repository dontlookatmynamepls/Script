local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local oldGui = playerGui:FindFirstChild("Bom2dev")
if oldGui then oldGui:Destroy() end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Bom2dev"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = playerGui

local ToggleButton = Instance.new("TextButton")
ToggleButton.Parent = ScreenGui
ToggleButton.Size = UDim2.new(0, 35, 0, 35)
ToggleButton.Position = UDim2.new(0, 7, 0.05, 80)
ToggleButton.Text = "Bom2dev"
ToggleButton.TextColor3 = Color3.new(1, 1, 1)
ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
ToggleButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
ToggleButton.BorderSizePixel = 2
ToggleButton.TextScaled = true
ToggleButton.Active = true
ToggleButton.Draggable = true

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 400, 0, 250)
MainFrame.Position = UDim2.new(0.5, -200, 0.5, -125)
MainFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
MainFrame.BorderColor3 = Color3.new(0, 0, 0)
MainFrame.BorderSizePixel = 4
MainFrame.Visible = false
MainFrame.Parent = ScreenGui

local Header = Instance.new("Frame")
Header.Size = UDim2.new(1, 0, 0, 40)
Header.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
Header.BorderColor3 = Color3.new(0, 0, 0)
Header.BorderSizePixel = 2
Header.Parent = MainFrame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -40, 1, 0)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.Text = "Bom2-GUI Trash Ez Deobfuscatorü§£ü§£ü§£"
Title.TextColor3 = Color3.new(0, 0, 0)
Title.BackgroundTransparency = 1
Title.TextScaled = true
Title.Font = Enum.Font.FredokaOne
Title.Parent = Header

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 40, 1, 0)
CloseButton.Position = UDim2.new(1, -40, 0, 0)
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.new(0, 0, 0)
CloseButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
CloseButton.BorderColor3 = Color3.new(0, 0, 0)
CloseButton.BorderSizePixel = 2
CloseButton.TextScaled = true
CloseButton.Parent = Header

CloseButton.MouseButton1Click:Connect(function()
	MainFrame.Visible = false
end)

local Content = Instance.new("ScrollingFrame")
Content.Name = "Content"
Content.Size = UDim2.new(1, -10, 1, -50)
Content.Position = UDim2.new(0, 5, 0, 45)
Content.BackgroundTransparency = 1
Content.BorderSizePixel = 0
Content.ScrollBarThickness = 8
Content.CanvasSize = UDim2.new(0, 0, 0, 1000)
Content.ClipsDescendants = true
Content.AutomaticCanvasSize = Enum.AutomaticSize.Y
Content.ScrollingDirection = Enum.ScrollingDirection.Y
Content.Parent = MainFrame

ToggleButton.MouseButton1Click:Connect(function()
	MainFrame.Visible = not MainFrame.Visible
end)

local scripts = {
{Text = "T√†ng h√¨nh", Script = [[
    if game.CoreGui:FindFirstChild("InvisibleGui") then
        game.CoreGui.InvisibleGui:Destroy()
    end

    game.StarterGui:SetCore("SendNotification", {
        Title = "K√≠ch ho·∫°t",
        Text = "T√†ng h√¨nh ƒë√£ ƒë∆∞·ª£c b·∫≠t!",
        Duration = 3
    })

    local success, err = pcall(function()
        loadstring(game:HttpGet("https://pastebin.com/raw/3Rnd9rHf"))()
    end)

    if not success then
        warn("L·ªói khi t·∫£i script t√†ng h√¨nh:", err)
        game.StarterGui:SetCore("SendNotification", {
            Title = "L·ªói",
            Text = "Kh√¥ng th·ªÉ t·∫£i script t√†ng h√¨nh!",
            Duration = 3
        })
    end
]]},
{Text = "Bay", Script = [[
        loadstring(game:HttpGet('https://raw.githubusercontent.com/XNEOFF/FlyGuiV3/main/FlyGuiV3.txt'))()
        game.StarterGui:SetCore("SendNotification", {
            Title = "Bay",
            Text = "ƒê√£ b·∫≠t ch·∫ø ƒë·ªô bay!",
            Duration = 4
        })
    ]]},
{Text = "ƒêi B·ªô Tr√™n Kh√¥ng", Script = [[
getgenv()._WalkOnVoid = not getgenv()._WalkOnVoid
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local platformName = "WalkOnVoidPlatform"

local function notify(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = 4
        })
    end)
end

local function removePlatform()
    local old = workspace:FindFirstChild(platformName)
    if old then old:Destroy() end
end

if getgenv()._WalkOnVoidConn then
    getgenv()._WalkOnVoidConn:Disconnect()
    getgenv()._WalkOnVoidConn = nil
end

if getgenv()._WalkOnVoid then
    notify("ƒê√£ B·∫≠t", "ƒêi b·ªô tr√™n kh√¥ng")

    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    char:WaitForChild("HumanoidRootPart")

    local root = char:FindFirstChild("HumanoidRootPart")

    if root then
        removePlatform()
        local platform = Instance.new("Part")
        platform.Name = platformName
        platform.Size = Vector3.new(50, 50, 50)
        platform.Anchored = true
        platform.Transparency = 1
        platform.Color = Color3.fromRGB(200, 200, 255)
        platform.CanCollide = true
        platform.Parent = workspace

        local baseY = root.Position.Y - 28.5

        getgenv()._WalkOnVoidConn = RunService.RenderStepped:Connect(function()
            if not root or not root.Parent then return end
            platform.Position = Vector3.new(root.Position.X, baseY, root.Position.Z)
        end)

        char:WaitForChild("Humanoid").Died:Connect(function()
            removePlatform()
            notify("ƒê√£ T·∫Øt", "ƒêi b·ªô tr√™n kh√¥ng!")
            getgenv()._WalkOnVoid = false
        end)
    else
        notify("L·ªói", "Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t.")
        getgenv()._WalkOnVoid = false
        return
    end
else
    notify("ƒê√£ T·∫Øt", "ƒêi b·ªô tr√™n kh√¥ng.")
    removePlatform()
end
]]},
{Text = "ƒê·ªãnh V·ªã Ng∆∞·ªùi Ch∆°i", Script = [[
if shared._ESPEnabled then
    shared._ESPEnabled = false
    for _, v in pairs(game.CoreGui:GetChildren()) do
        if v.Name == "_PlayerESP" then v:Destroy() end
    end
    game.StarterGui:SetCore("SendNotification", {
        Title = "ƒê·ªãnh V·ªã Ng∆∞·ªùi Ch∆°i",
        Text = "ƒê√£ t·∫Øt!",
        Duration = 2
    })
    return
end

shared._ESPEnabled = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local espFolder = Instance.new("Folder")
espFolder.Name = "_PlayerESP"
espFolder.Parent = game.CoreGui

local function createBillboard(player, character)
    local head = character:FindFirstChild("Head")
    if not head then return end

    local old = espFolder:FindFirstChild(player.Name .. "_ESP")
    if old then old:Destroy() end

    local Billboard = Instance.new("BillboardGui")
    Billboard.Name = player.Name .. "_ESP"
    Billboard.Adornee = head
    Billboard.AlwaysOnTop = true
    Billboard.Size = UDim2.new(0, 100, 0, 30)
    Billboard.StudsOffset = Vector3.new(0, 2, 0)
    Billboard.Parent = espFolder

    local nameLabel = Instance.new("TextLabel")
    nameLabel.BackgroundTransparency = 1
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = Color3.new(1, 1, 1)
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = Billboard

    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "Distance"
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
    distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
    distanceLabel.Text = "0m"
    distanceLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    distanceLabel.TextStrokeTransparency = 0
    distanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    distanceLabel.TextScaled = true
    distanceLabel.Font = Enum.Font.SourceSansBold
    distanceLabel.Parent = Billboard
end

local function setupPlayer(player)
    if player == LocalPlayer then return end

    if player.Character then
        createBillboard(player, player.Character)
    end
    player.CharacterAdded:Connect(function(character)
        local head = character:WaitForChild("Head", 5)
        if head then
            createBillboard(player, character)
        end
    end)
end

for _, player in ipairs(Players:GetPlayers()) do
    setupPlayer(player)
end

Players.PlayerAdded:Connect(function(player)
    setupPlayer(player)
end)

RunService.RenderStepped:Connect(function()
    if not shared._ESPEnabled then return end
    for _, esp in pairs(espFolder:GetChildren()) do
        local playerName = esp.Name:gsub("_ESP", "")
        local player = Players:FindFirstChild(playerName)
        if player and player.Character and player.Character:FindFirstChild("Head") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
            local distance = math.floor((player.Character.Head.Position - LocalPlayer.Character.Head.Position).Magnitude)
            local distLabel = esp:FindFirstChild("Distance")
            if distLabel then
                distLabel.Text = distance .. "m"
            end
        end
    end
end)

game.StarterGui:SetCore("SendNotification", {
    Title = "ƒê·ªãnh V·ªã Ng∆∞·ªùi Ch∆°i",
    Text = "ƒê√£ b·∫≠t!",
    Duration = 2
})
]]},
{Text = "Xuy√™n T∆∞·ªùng", Script = [[
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

_G.XuyenTuong = not _G.XuyenTuong

if _G.NoclipConnection then
    _G.NoclipConnection:Disconnect()
    _G.NoclipConnection = nil
end

local function setCollision(state)
    local char = player.Character or player.CharacterAdded:Wait()
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = state
        end
    end
end

if _G.XuyenTuong then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Xuy√™n T∆∞·ªùng",
        Text = "ƒê√£ b·∫≠t xuy√™n t∆∞·ªùng!",
        Duration = 4
    })

    _G.NoclipConnection = RunService.Stepped:Connect(function()
        local char = player.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)

    if not _G.RespawnNoclipConn then
        _G.RespawnNoclipConn = player.CharacterAdded:Connect(function()
            if _G.XuyenTuong then
                task.wait(0.2)
                setCollision(false)
            end
        end)
    end
else
    setCollision(true)

    if _G.RespawnNoclipConn then
        _G.RespawnNoclipConn:Disconnect()
        _G.RespawnNoclipConn = nil
    end

    game.StarterGui:SetCore("SendNotification", {
        Title = "Xuy√™n T∆∞·ªùng",
        Text = "ƒê√£ t·∫Øt xuy√™n t∆∞·ªùng!",
        Duration = 4
    })
end
]]},
{Text = "T·ªëc Bi·∫øn", Script = [[
	local player = game.Players.LocalPlayer
	local mouse = player:GetMouse()
	_G.TeleportState = not _G.TeleportState

	if _G.TeleportConnection then
		_G.TeleportConnection:Disconnect()
		_G.TeleportConnection = nil
	end

	if _G.TeleportState then
		game.StarterGui:SetCore("SendNotification", {
			Title = "T·ªëc Bi·∫øn",
			Text = "Ch·∫°m ƒë·ªÉ d·ªãch chuy·ªÉn",
			Duration = 5,
		})

		_G.TeleportConnection = mouse.Button1Down:Connect(function()
			local char = player.Character
			if not char or not char:FindFirstChild("HumanoidRootPart") then return end
			local hrp = char.HumanoidRootPart

			local target = mouse.Hit.Position
			local current = hrp.Position
			local dist = (target - current).Magnitude

			if dist <= 1000 then
				hrp.CFrame = CFrame.new(target + Vector3.new(0, 5, 0))
			else
				local dir = (target - current).Unit
				local newPos = current + dir * 1000
				hrp.CFrame = CFrame.new(newPos + Vector3.new(0, 5, 0))
			end

			_G.TeleportConnection:Disconnect()
			_G.TeleportConnection = nil
			_G.TeleportState = false
		end)
	end
]]},
{Text = "T·ªëc ƒê·ªô 1",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 1

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
]]},
{Text = "T·ªëc ƒê·ªô 10",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 10

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
    ]]},
{Text = "T·ªëc ƒê·ªô 20",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 20

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
    ]]},
{Text = "T·ªëc ƒê·ªô 30",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 30

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
    ]]},
{Text = "T·ªëc ƒê·ªô 50",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 50

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
    ]]},
{Text = "T·ªëc ƒê·ªô 100",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 100

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
    ]]},
{Text = "T·ªëc ƒê·ªô 150",
    Script = [[
        local player = game.Players.LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        local targetSpeed = 150

        if shared._CurrentSpeedLoop and shared._CurrentSpeedTarget == targetSpeed then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
            shared._CurrentSpeedTarget = nil
            if humanoid then humanoid.WalkSpeed = 16 end
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed",
                Text = "ƒê√£ t·∫Øt tƒÉng t·ªëc, tr·ªü v·ªÅ m·∫∑c ƒë·ªãnh!",
                Duration = 3
            })
            return
        end

        if shared._CurrentSpeedLoop then
            shared._CurrentSpeedLoop:Disconnect()
            shared._CurrentSpeedLoop = nil
        end

        shared._CurrentSpeedTarget = targetSpeed

        if humanoid then humanoid.WalkSpeed = targetSpeed end

        shared._CurrentSpeedLoop = game:GetService("RunService").RenderStepped:Connect(function(dt)
            if humanoid and humanoid.WalkSpeed ~= targetSpeed then
                humanoid.WalkSpeed = targetSpeed
            end
            wait(1.5)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Speed",
            Text = "ƒê√£ k√≠ch ho·∫°t t·ªëc ƒë·ªô " .. tostring(targetSpeed),
            Duration = 3
        })
    ]]},
{Text = "D·ªãch Chuy·ªÉn ƒê·∫øn Ng∆∞·ªùi Ch∆°i G·∫ßn Nh·∫•t", Script = [[
if getgenv().TeleportAndRotateBody then
    getgenv().TeleportAndRotateBody = false
    game.StarterGui:SetCore("SendNotification", {
        Title = "ƒê√£ t·∫Øt",
        Text = "ƒê√£ T·∫Øt D·ªãch Chuy·ªÉn",
        Duration = 3
    })
    return
end

getgenv().TeleportAndRotateBody = true
game.StarterGui:SetCore("SendNotification", {
    Title = "ƒê√£ b·∫≠t",
    Text = "ƒê√£ b·∫≠t d·ªãch chuy·ªÉn ƒë·∫øn ng∆∞·ªùi g·∫ßn nh·∫•t!",
    Duration = 3
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local function getRoot(character)
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function getNearestPlayer()
    local myChar = LocalPlayer.Character
    local myRoot = getRoot(myChar)
    if not myRoot then return nil end

    local closest, minDist = nil, math.huge
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local root = getRoot(plr.Character)
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local ff = plr.Character:FindFirstChildOfClass("ForceField")
            if root and humanoid and humanoid.Health > 0 and not ff then
                local dist = (myRoot.Position - root.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closest = plr
                end
            end
        end
    end
    return closest
end

task.spawn(function()
    while getgenv().TeleportAndRotateBody do
        local char = LocalPlayer.Character
        local root = getRoot(char)
        local head = char and char:FindFirstChild("Head")
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if not root or not head or not humanoid then task.wait(0.05) continue end

        local targetPlr = getNearestPlayer()
        if targetPlr and targetPlr.Character then
            local targetRoot = getRoot(targetPlr.Character)
            if targetRoot then
                local direction = (targetRoot.Position - root.Position).Unit
                local position = targetRoot.Position - direction * 2
                
                -- C·∫≠p nh·∫≠t v·ªã tr√≠ nh√¢n v·∫≠t g·∫ßn ng∆∞·ªùi ch∆°i kia
                root.CFrame = CFrame.new(position, targetRoot.Position)

                -- Xoay ƒë·∫ßu nh√¢n v·∫≠t v·ªÅ ph√≠a ng∆∞·ªùi kia
                local lookVector = (targetRoot.Position - head.Position).Unit
                local headCF = CFrame.new(head.Position, head.Position + lookVector)
                head.CFrame = headCF

                -- Gi·ªØ nguy√™n camera ban ƒë·∫ßu
                local currentCameraCF = Camera.CFrame
                task.defer(function()
                    Camera.CFrame = currentCameraCF
                end)
            end
        end
        task.wait(0.05)
    end
end)
]]},
{Text = "Nh√¨n Trong B√≥ng T·ªëi", Script = [[
getgenv()._NightVision = not getgenv()._NightVision

local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")

local function notify(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = 4
        })
    end)
end

local cc = Lighting:FindFirstChild("NV_CC") or Instance.new("ColorCorrectionEffect")
cc.Name = "NV_CC"
cc.Parent = Lighting

if getgenv()._NightVision and not getgenv()._NV_Backup then
    getgenv()._NV_Backup = {
        FogEnd = Lighting.FogEnd,
        FogStart = Lighting.FogStart,
        FogColor = Lighting.FogColor,
        Brightness = Lighting.Brightness,
        ClockTime = Lighting.ClockTime,
        GlobalShadows = Lighting.GlobalShadows,
    }
end

if getgenv()._NightVision then
    notify("ƒê√£ K√≠ch Ho·∫°t", "Kh·∫£ nƒÉng nh√¨n trong b√≥ng t·ªëi ƒë√£ ƒë∆∞·ª£c b·∫≠t!")

    getgenv()._NightVisionLoop = RunService.RenderStepped:Connect(function()
        Lighting.FogColor = Color3.fromRGB(255, 255, 255)
        Lighting.FogEnd = 999999
        Lighting.FogStart = 999999
        Lighting.Brightness = 4
        Lighting.ClockTime = 14
        Lighting.GlobalShadows = false

        cc.Enabled = true
        cc.Brightness = 0.2
        cc.Contrast = 0.3
        cc.Saturation = 0.2
        cc.TintColor = Color3.fromRGB(255, 255, 255)
    end)
else
    notify("ƒê√£ T·∫Øt", "Kh·∫£ nƒÉng nh√¨n trong b√≥ng t·ªëi ƒë√£ b·ªã t·∫Øt.")

    if getgenv()._NightVisionLoop then
        getgenv()._NightVisionLoop:Disconnect()
        getgenv()._NightVisionLoop = nil
    end

    cc.Enabled = false

    if getgenv()._NV_Backup then
        Lighting.FogEnd = getgenv()._NV_Backup.FogEnd
        Lighting.FogStart = getgenv()._NV_Backup.FogStart
        Lighting.FogColor = getgenv()._NV_Backup.FogColor
        Lighting.Brightness = getgenv()._NV_Backup.Brightness
        Lighting.ClockTime = getgenv()._NV_Backup.ClockTime
        Lighting.GlobalShadows = getgenv()._NV_Backup.GlobalShadows
        getgenv()._NV_Backup = nil
    end
end
]]},
{Text = "TƒÉng T·ªëc T∆∞∆°ng T√°c",
 Script = [[
    local StarterGui = game:GetService("StarterGui")
    local RunService = game:GetService("RunService")

    -- Toggle
    if shared._ProxFast then
        -- disable
        if shared._OldProx then
            for prompt, old in pairs(shared._OldProx) do
                if prompt and prompt.Parent then
                    prompt.HoldDuration = old
                end
            end
        end
        if shared._ProxConn then
            shared._ProxConn:Disconnect()
            shared._ProxConn = nil
        end
        shared._ProxFast = nil
        shared._OldProx = nil
        StarterGui:SetCore("SendNotification", {
            Title = "Proximity",
            Text = "ƒê√£ t·∫Øt TƒÉng T·ªëc Proximity",
            Duration = 3
        })
        return
    end

    -- enable
    shared._ProxFast = true
    shared._OldProx = {}
    StarterGui:SetCore("SendNotification", {
        Title = "Proximity",
        Text = "ƒê√£ b·∫≠t TƒÉng T·ªëc Proximity (0.1s)",
        Duration = 3
    })

    -- function to boost a prompt
    local function boost(p)
        if not shared._OldProx[p] then
            shared._OldProx[p] = p.HoldDuration
        end
        p.HoldDuration = 0.1
    end

    -- initial boost
    for _, p in ipairs(workspace:GetDescendants()) do
        if p:IsA("ProximityPrompt") then
            boost(p)
        end
    end

    -- listen for new prompts
    shared._ProxConn = RunService.Heartbeat:Connect(function()
        for _, p in ipairs(workspace:GetDescendants()) do
            if p:IsA("ProximityPrompt") then
                boost(p)
            end
        end
    end)
]]},
{Text = "Shader", Script = [[
local Lighting = game:GetService("Lighting")
if not Lighting:FindFirstChild("PatrickShaderFlag") then
	loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/unk/refs/heads/main/patrick%20shader.luau"))()

	local flag = Instance.new("BoolValue")
	flag.Name = "PatrickShaderFlag"
	flag.Parent = Lighting
end

local ReflectancePart = 0.35
local ReflectanceChar = 0.5

local ReflectFlag = Lighting:FindFirstChild("ReflectanceToggle")
if not ReflectFlag then
	ReflectFlag = Instance.new("BoolValue")
	ReflectFlag.Name = "ReflectanceToggle"
	ReflectFlag.Value = true -- M·∫∑c ƒë·ªãnh b·∫≠t
	ReflectFlag.Parent = Lighting
else
	ReflectFlag.Value = not ReflectFlag.Value -- Toggle
end

local reflectOn = ReflectFlag.Value

-- Ph·∫£n chi·∫øu Part
for _, part in ipairs(workspace:GetDescendants()) do
	if part:IsA("BasePart") and part.Transparency < 0.8 then
		part.Reflectance = reflectOn and ReflectancePart or 0
	end
end

local Players = game:GetService("Players")
for _, player in ipairs(Players:GetPlayers()) do
	local char = player.Character
	if char then
		for _, p in ipairs(char:GetDescendants()) do
			if p:IsA("BasePart") then
				p.Reflectance = reflectOn and ReflectanceChar or 0
			end
		end
	end
end

game:GetService("StarterGui"):SetCore("SendNotification", {
	Title = "TestShader",
	Text = "Ph·∫£n chi·∫øu: " .. (reflectOn and "B·∫¨T" or "T·∫ÆT"),
	Duration = 5
})
]]},
{Text = "Ch·ªëng b·ªã ƒë·∫©y khi ƒë·ª©ng y√™n",
	Script = [[
local Players     = game:GetService("Players")
local RunService  = game:GetService("RunService")
local StarterGui  = game:GetService("StarterGui")
local player      = Players.LocalPlayer
local character   = player.Character or player.CharacterAdded:Wait()
local humanoid    = character:WaitForChild("Humanoid")
local hrp         = character:WaitForChild("HumanoidRootPart")

if shared._AntiPushLoop then
    shared._AntiPushLoop:Disconnect()
    shared._AntiPushLoop = nil
    shared._AntiPushPlaying = false

    if hrp then
        hrp.Anchored = false
    end

    StarterGui:SetCore("SendNotification", {
        Title = "Ch·ªëng ƒë·∫©y",
        Text = "ƒê√£ t·∫Øt ch·ªëng b·ªã ƒë·∫©y khi ƒë·ª©ng y√™n",
        Duration = 3
    })
    return
end

local idleAnim = Instance.new("Animation")
idleAnim.AnimationId = "rbxassetid://507766388"
local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
local idleTrack = animator:LoadAnimation(idleAnim)
idleTrack.Looped = true

local lastMoveTime = tick()
shared._AntiPushPlaying = false

local function playIdle()
    if not shared._AntiPushPlaying then
        shared._AntiPushPlaying = true
        hrp.Anchored = true
        idleTrack:Play()
    end
end

local function stopIdle()
    if shared._AntiPushPlaying then
        shared._AntiPushPlaying = false
        hrp.Anchored = false
        idleTrack:Stop()
    end
    lastMoveTime = tick()
end

humanoid:GetPropertyChangedSignal("MoveDirection"):Connect(function()
    if humanoid.MoveDirection.Magnitude > 0 then
        stopIdle()
    end
end)

game:GetService("UserInputService").JumpRequest:Connect(function()
    stopIdle()
end)

shared._AntiPushLoop = RunService.Heartbeat:Connect(function()
    local grounded = humanoid.FloorMaterial ~= Enum.Material.Air
    local moving = humanoid.MoveDirection.Magnitude > 0
    local idleDelay = 1.5

    if not moving then
        if not grounded or (tick() - lastMoveTime > idleDelay) then
            playIdle()
        end
    else
        stopIdle()
    end
end)

StarterGui:SetCore("SendNotification", {
    Title = "Ch·ªëng ƒë·∫©y",
    Text = "ƒê√£ b·∫≠t ch·ªëng b·ªã ƒë·∫©y khi ƒë·ª©ng y√™n",
    Duration = 3
})
]]},
{Text = "Fake Lag V1",
    Script = [[

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function createGUI()
local ScreenGui = Instance.new("ScreenGui")
local DraggableButton = Instance.new("TextButton")
local TextBoxWait = Instance.new("TextBox")
local TextBoxDelay = Instance.new("TextBox")
local UserInputService = game:GetService("UserInputService")

ScreenGui.Name = "FakeLagGUI"
ScreenGui.Parent = game.CoreGui

DraggableButton.Parent = ScreenGui
DraggableButton.BackgroundColor3 = Color3.new(0, 0, 0)
DraggableButton.Size = UDim2.new(0, 100, 0, 50)
DraggableButton.Position = UDim2.new(0.5, 200, 0.5, -50)
DraggableButton.Text = "B·∫≠t Lag"
DraggableButton.TextColor3 = Color3.new(1, 1, 1)
DraggableButton.BorderSizePixel = 0
DraggableButton.Font = Enum.Font.SourceSans
DraggableButton.TextSize = 18
DraggableButton.AutoButtonColor = false
DraggableButton.Active = true
DraggableButton.Draggable = true

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = DraggableButton

TextBoxWait.Parent = ScreenGui
TextBoxWait.Size = UDim2.new(0, 100, 0, 30)
TextBoxWait.Position = UDim2.new(0, 0, 0, 0)
TextBoxWait.PlaceholderText = "Th·ªùi Gian ƒê·ª£i"
TextBoxWait.Text = "0.05"
TextBoxWait.TextColor3 = Color3.new(1, 1, 1)
TextBoxWait.BackgroundColor3 = Color3.new(0, 0, 0)
TextBoxWait.BackgroundTransparency = 0.5

TextBoxDelay.Parent = ScreenGui
TextBoxDelay.Size = UDim2.new(0, 100, 0, 30)
TextBoxDelay.Position = UDim2.new(0, 125, 0, 0)
TextBoxDelay.PlaceholderText = "Delay Time"
TextBoxDelay.Text = "0.4"
TextBoxDelay.TextColor3 = Color3.new(1, 1, 1)
TextBoxDelay.BackgroundColor3 = Color3.new(0, 0, 0)
TextBoxDelay.BackgroundTransparency = 0.5

local FakeLag = false
local waitTime = 0.05
local delayTime = 0.4

DraggableButton.MouseButton1Click:Connect(function()
FakeLag = not FakeLag
if FakeLag then
DraggableButton.Text = "FakeLag: B·∫≠t"
else
DraggableButton.Text = "FakeLag: T·∫Øt"
end
end)

TextBoxWait.FocusLost:Connect(function()
waitTime = tonumber(TextBoxWait.Text) or waitTime
end)

TextBoxDelay.FocusLost:Connect(function()
delayTime = tonumber(TextBoxDelay.Text) or delayTime
end)

coroutine.wrap(function()
while wait(waitTime) do
if FakeLag then
local character = player.Character
if character and character:FindFirstChild("HumanoidRootPart") then
character.HumanoidRootPart.Anchored = true
wait(delayTime)
character.HumanoidRootPart.Anchored = false
end
end
end
end)()

-- Falling button
local FallingButton = Instance.new("TextButton")
FallingButton.Parent = ScreenGui  -- Ensure it is parented to ScreenGui
FallingButton.BackgroundColor3 = Color3.new(0, 0, 0)
FallingButton.Size = UDim2.new(0, 100, 0, 50)
FallingButton.Position = UDim2.new(0.5, 200, 0.5, 0)
FallingButton.Text = "R∆°i T·ª± Do"
FallingButton.TextColor3 = Color3.new(1, 1, 1)
FallingButton.BorderSizePixel = 0
FallingButton.Font = Enum.Font.SourceSans
FallingButton.TextSize = 24
FallingButton.AutoButtonColor = false
FallingButton.Active = true
FallingButton.Draggable = true

local UICorner2 = Instance.new("UICorner")
UICorner2.CornerRadius = UDim.new(0, 10)
UICorner2.Parent = FallingButton

local isPlatformStand = false
local canStandUp = false

game:GetService("RunService").RenderStepped:Connect(function()
if draggingFalling and (tick() - holdStart) >= 5 then
FallingButton.Visible = false
end
end)

FallingButton.MouseButton1Click:Connect(function()
if player.Character and player.Character:FindFirstChild("Humanoid") then
local humanoid = player.Character.Humanoid
if not isPlatformStand then
humanoid.PlatformStand = true
humanoid:Move(Vector3.new(0, -50, 0))
canStandUp = true
isPlatformStand = true
elseif canStandUp then
humanoid.PlatformStand = false
isPlatformStand = false
canStandUp = false
end
end
end)

end

createGUI()
    ]]},
{Text = "Fake Lag V2",
    Script = [[
        local StarterGui = game:GetService("StarterGui")
        local RunService = game:GetService("RunService")
        local Players    = game:GetService("Players")
        local player     = Players.LocalPlayer
        local char       = player.Character or player.CharacterAdded:Wait()
        local humanoid   = char:WaitForChild("Humanoid")
        local hrp        = char:WaitForChild("HumanoidRootPart")

        local function enableFakeLag()
            StarterGui:SetCore("SendNotification", {
                Title = "Fake Lag V2",
                Text = "Fake Lag V2 ON",
                Duration = 2
            })
            shared._PosHistory = {}
            shared._PrevPos    = hrp.Position
            shared._MoveAcc    = 0
            shared._FallCount  = 0
            shared._JumpCount  = 0

            shared._V2Conn = RunService.RenderStepped:Connect(function()
                local now = tick()
                if humanoid.WalkSpeed > 16 then
                    local s = humanoid.WalkSpeed
                    humanoid.WalkSpeed = 16
                    for _, t in ipairs(char:GetDescendants()) do
                        if t:IsA("AnimationTrack") then
                            t:AdjustSpeed(s/16)
                        end
                    end
                end
                table.insert(shared._PosHistory, {time = now, cf = hrp.CFrame})
                while #shared._PosHistory > 0 and now - shared._PosHistory[1].time > 5 do
                    table.remove(shared._PosHistory, 1)
                end
                local delta = (hrp.Position - shared._PrevPos).Magnitude
                shared._MoveAcc = shared._MoveAcc + delta
                shared._PrevPos = hrp.Position

                if shared._MoveAcc >= 2 then
                    shared._MoveAcc = 0
                    if math.random() < 0.3 then
                        local targetTime = now - 1.5
                        local best = shared._PosHistory[1]
                        for _, e in ipairs(shared._PosHistory) do
                            if math.abs(e.time - targetTime) < math.abs(best.time - targetTime) then
                                best = e
                            end
                        end
                        if best then hrp.CFrame = best.cf end
                    end
                end

                if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                    if shared._FallCount < 3 and math.random() < 0.3 then
                        shared._FallCount = shared._FallCount + 1
                        local cf = hrp.CFrame
                        hrp.Anchored = true
                        task.delay(math.random(1,3), function()
                            hrp.Anchored = false
                            hrp.CFrame = cf
                        end)
                    end
                end

                if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                    if shared._JumpCount < 3 and math.random() < 0.3 then
                        shared._JumpCount = shared._JumpCount + 1
                        local cf = hrp.CFrame
                        hrp.Anchored = true
                        task.delay(math.random(1,3), function()
                            hrp.Anchored = false
                            hrp.CFrame = cf
                        end)
                    end
                end
            end)
        end

        local function disableFakeLag()
            if shared._V2Conn then
                shared._V2Conn:Disconnect()
                shared._V2Conn = nil
            end
            shared._PosHistory = nil
            shared._PrevPos    = nil
            shared._MoveAcc    = nil
            shared._FallCount  = nil
            shared._JumpCount  = nil
            StarterGui:SetCore("SendNotification", {
                Title = "Fake Lag V2",
                Text = "Fake Lag V2 OFF",
                Duration = 2
            })
        end

        if shared._FakeLagV2Enabled then
            shared._FakeLagV2Enabled = false
            disableFakeLag()
        else
            shared._FakeLagV2Enabled = true
            enableFakeLag()
        end
    ]]},
{Text = "Xoay khi di chuy·ªÉn", Script = [[
local Players             = game:GetService("Players")
local RunService          = game:GetService("RunService")
local StarterGui          = game:GetService("StarterGui")

local player              = Players.LocalPlayer

local ROTATIONS_PER_SECOND = 0.05
local MAX_TORQUE           = 1e5

if shared._RotationEnabled == nil then
    shared._RotationEnabled = false
end

if shared._RotationLoop then
    shared._RotationLoop:Disconnect()
    shared._RotationLoop = nil
end

local function toggleRotation()
    shared._RotationEnabled = not shared._RotationEnabled
    StarterGui:SetCore("SendNotification", {
        Title    = "Xoay khi di chuy·ªÉn",
        Text     = shared._RotationEnabled and "ƒê√£ b·∫≠t xoay khi di chuy·ªÉn" or "ƒê√£ t·∫Øt xoay khi di chuy·ªÉn",
        Duration = 3,
    })
    if shared._RotationEnabled then
        -- force recreate loop
        setupRotation()
    end
end

function setupRotation()
    local char = player.Character or player.CharacterAdded:Wait()
    local hum  = char:WaitForChild("Humanoid")
    local hrp  = char:WaitForChild("HumanoidRootPart")

    hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
    hum.PlatformStand = false

    local bav = hrp:FindFirstChild("RotateSpin")
    if not bav then
        bav = Instance.new("BodyAngularVelocity")
        bav.Name       = "RotateSpin"
        bav.MaxTorque = Vector3.new(MAX_TORQUE, MAX_TORQUE, MAX_TORQUE)
        bav.P         = 1000
        bav.Parent    = hrp
    end

    if shared._RotationLoop then
        shared._RotationLoop:Disconnect()
    end

    shared._RotationLoop = RunService.RenderStepped:Connect(function()
        if not shared._RotationEnabled then
            bav.AngularVelocity = Vector3.new(0,0,0)
            return
        end
        local dir = hum.MoveDirection
        if dir.Magnitude > 0.1 then
            local axis  = dir:Cross(Vector3.new(0,1,0)).Unit
            local omega = 2 * math.pi * ROTATIONS_PER_SECOND
            bav.AngularVelocity = axis * omega
        else
            bav.AngularVelocity = Vector3.new(0,0,0)
        end
    end)
end

player.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart")
    if shared._RotationEnabled then
        setupRotation()
    end
end)

if player.Character and shared._RotationEnabled then
    setupRotation()
end

toggleRotation()
]]},
{Text = "Animation Si√™u Nhanh", Script = [[
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer

_G.SuperAnim = not _G.SuperAnim
_G.SuperAnimLastClick = _G.SuperAnimLastClick or 0

if _G.SuperAnimConn then _G.SuperAnimConn:Disconnect() _G.SuperAnimConn = nil end
if _G.SuperAnimCharConn then _G.SuperAnimCharConn:Disconnect() _G.SuperAnimCharConn = nil end

local function notify(text)
	pcall(function()
		StarterGui:SetCore("SendNotification", {
			Title = "Animation Si√™u Nhanh",
			Text = text,
			Duration = 3
		})
	end)
end

local function applySuperAnimation(char, instant)
	local humanoid = char:WaitForChild("Humanoid")
	local animator = humanoid:FindFirstChildWhichIsA("Animator")

	local minSpeed = 500
	local maxSpeed = 500
	local duration = 120
	local elapsed = 0
	local currentSpeed = minSpeed

	if instant then
		currentSpeed = maxSpeed
		elapsed = duration
	end

	_G.SuperAnimConn = RunService.Heartbeat:Connect(function(dt)
		if not _G.SuperAnim then return end
		if humanoid and humanoid.WalkSpeed ~= 16 then
			humanoid.WalkSpeed = 16
		end

		if not instant and currentSpeed < maxSpeed then
			elapsed = math.min(elapsed + dt, duration)
			currentSpeed = math.clamp(minSpeed + ((elapsed / duration) * (maxSpeed - minSpeed)), minSpeed, maxSpeed)
		end

		if animator then
			for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
				if track.IsPlaying then
					local animSpeed = currentSpeed / 16
					pcall(function()
						track:AdjustSpeed(animSpeed)
					end)
				end
			end
		end
	end)
end

if _G.SuperAnim then
	local now = tick()
	local doubleClick = now - _G.SuperAnimLastClick <= 3
	_G.SuperAnimLastClick = now

	if doubleClick then
		notify("TƒÉng t·ªëc ƒë·ªô animation ngay l√™n 750!")
	else
		notify("ƒê√£ TƒÉng T·ªëc Animation")
	end

	if player.Character then
		applySuperAnimation(player.Character, doubleClick)
	end

	_G.SuperAnimCharConn = player.CharacterAdded:Connect(function(char)
		if _G.SuperAnim then
			task.wait(1)
			applySuperAnimation(char, false)
		end
	end)
else
	notify("ƒê√£ t·∫Øt animation si√™u nhanh.")
end
]]},
{Text = "Di Chuy·ªÉn Xoay Ngang 360‚Å∞", Script = [[
getgenv()._SpinWalkY = not getgenv()._SpinWalkY

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer

local function notify(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = 4
        })
    end)
end

if getgenv()._SpinWalkX and getgenv()._SpinConnX then
    getgenv()._SpinWalkX = false
    getgenv()._SpinConnX:Disconnect()
    getgenv()._SpinConnX = nil
    notify("ƒê√£ T·∫Øt", "ƒê√£ t·∫Øt Xoay D·ªçc v√¨ b·∫°n b·∫≠t Xoay Ngang.")
end

if getgenv()._SpinConnY then
    getgenv()._SpinConnY:Disconnect()
    getgenv()._SpinConnY = nil
end

if getgenv()._SpinWalkY then
    notify("ƒê√£ K√≠ch Ho·∫°t", "Nh√¢n v·∫≠t s·∫Ω xoay NGANG khi di chuy·ªÉn!")
    getgenv()._SpinConnY = RunService.RenderStepped:Connect(function()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MoveDirection.Magnitude > 0 and hrp then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(100), 0)
        end
    end)
else
    notify("ƒê√£ T·∫Øt", "ƒê√£ t·∫Øt Xoay Ngang khi di chuy·ªÉn.")
end
]]},
{Text = "ƒêi Tr√™n T∆∞·ªùng", Script = [[
getgenv()._WallWalkToggle = not getgenv()._WallWalkToggle

local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local function notify(title, msg)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = msg,
            Duration = 4
        })
    end)
end

local function isWallWalking()
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return false end
    local root = char.HumanoidRootPart

    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {char}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local directions = {
        Vector3.new(0, -1, 0),
        Vector3.new(0, 1, 0),
        root.CFrame.RightVector,
        -root.CFrame.RightVector,
        root.CFrame.LookVector,
        -root.CFrame.LookVector
    }

    for _, dir in ipairs(directions) do
        local ray = workspace:Raycast(root.Position, dir * 4, rayParams)
        if ray and ray.Instance and (ray.Instance:IsA("Part") or ray.Instance:IsA("MeshPart")) then
            return true
        end
    end
    return false
end

if getgenv()._WallCamFix then
	getgenv()._WallCamFix:Disconnect()
	getgenv()._WallCamFix = nil
end

if getgenv()._WallWalkToggle then
    notify("ƒêi Tr√™n T∆∞·ªùng", "ƒê√£ B·∫≠t")
    loadstring(game:HttpGet("https://pastebin.com/raw/zXk4Rq2r"))()

    getgenv()._WallCamFix = RunService.RenderStepped:Connect(function()
        local char = player.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then return end
        if not isWallWalking() then return end

        local root = char.HumanoidRootPart
        local rootUp = root.CFrame.UpVector
        local camPos = camera.CFrame.Position
        local camLook = camera.CFrame.LookVector

        if rootUp:Dot(Vector3.new(0, 1, 0)) < 0 then
            local newCF = CFrame.lookAt(camPos, camPos + camLook, Vector3.new(0, -1, 0))
            camera.CFrame = newCF
        end
    end)
else
    notify("ƒêi Tr√™n T∆∞·ªùng", "ƒê√£ T·∫Øt")
    if getgenv()._WallCamFix then
        getgenv()._WallCamFix:Disconnect()
        getgenv()._WallCamFix = nil
    end
end
]]},
{Text = "B·∫ª Kho√° Camera", Script = [[
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = game.Workspace.CurrentCamera

game.StarterGui:SetCore("SendNotification", {
    Title = "B·∫ª Kho√° Camera",
    Text = "ƒê√£ b·∫ª kho√° camera!",
    Duration = 3
})

local function unlockCamera()
    player.CameraMode = Enum.CameraMode.Classic
    player.CameraMaxZoomDistance = 1000
    player.CameraMinZoomDistance = 0.5
    camera.CameraType = Enum.CameraType.Custom
end

unlockCamera()

game:GetService("RunService").RenderStepped:Connect(function()
    if player.CameraMode ~= Enum.CameraMode.Classic then
        player.CameraMode = Enum.CameraMode.Classic
    end
    if player.CameraMaxZoomDistance < 50 then
        player.CameraMaxZoomDistance = 50
    end
    if player.CameraMinZoomDistance > 0.5 then
        player.CameraMinZoomDistance = 0.5
    end
    if camera.CameraType ~= Enum.CameraType.Custom then
        camera.CameraType = Enum.CameraType.Custom
    end
end)
]]},
{Text = "RSS", Script = [[
	local player = game.Players.LocalPlayer
	local me = player.Character or player.CharacterAdded:Wait()

	_G.RSS_Enabled = not _G.RSS_Enabled

	if _G.RSS_Connection then
		_G.RSS_Connection:Disconnect()
		_G.RSS_Connection = nil
	end

	if _G.RSS_Enabled then
		game.StarterGui:SetCore("SendNotification", {
			Title = "RSS",
			Text = "Hi·ªáu ·ª©ng ƒë√£ b·∫≠t",
			Duration = 5,
		})

		local bbg = Instance.new("BillboardGui", me)
		bbg.Name = "stuf"
		bbg.Adornee = me
		bbg.Size = UDim2.new(2.5, 0, 2.5, 0)

		local tlb = Instance.new("TextLabel")
		tlb.Text = "#Om¬≤ B‚Å∞M2 +Gm2 ‚Ç¨o^^2 bCm¬≤ B.m‚Ç´"
		tlb.Font = Enum.Font.SourceSansBold
		tlb.TextSize = 48
		tlb.TextColor3 = Color3.new(1, 0, 0)
		tlb.Size = UDim2.new(1.25, 0, 1.25, 0)
		tlb.Position = UDim2.new(-0.125, -22, -1.1, 0)
		tlb.BackgroundTransparency = 1
		tlb.Parent = bbg

		local function applyEffects(obj)
			for _, v in ipairs(obj:GetChildren()) do
				if v:IsA("BasePart") then
					v.BrickColor = BrickColor.new("Really black")
					v.TopSurface = "Smooth"
					v.BottomSurface = "Smooth"

					local s = Instance.new("SelectionBox", v)
					s.Adornee = v
					s.Color = BrickColor.new("Really red")

					local a = Instance.new("PointLight", v)
					a.Color = Color3.new(1, 0, 0)
					a.Range = 15
					a.Brightness = 5

					local f = Instance.new("Fire", v)
					f.Size = 19
					f.Heat = 22
				end

				if #v:GetChildren() > 0 then
					applyEffects(v)
				end
			end
		end

		applyEffects(workspace)

		local lighting = game.Lighting
		lighting.TimeOfDay = "00:00:00"
		lighting.Brightness = 0
		lighting.ShadowColor = Color3.new(0, 0, 0)
		lighting.Ambient = Color3.new(1, 0, 0)
		lighting.FogEnd = 200
		lighting.FogColor = Color3.new(0, 0, 0)

	else
		game.StarterGui:SetCore("SendNotification", {
			Title = "RSS",
			Text = "Hi·ªáu ·ª©ng ƒë√£ t·∫Øt",
			Duration = 5,
		})

		if me:FindFirstChild("stuf") then
			me.stuf:Destroy()
		end

		for _, part in ipairs(workspace:GetDescendants()) do
			if part:IsA("SelectionBox") or part:IsA("Fire") or part:IsA("PointLight") then
				part:Destroy()
			end
		end

		local lighting = game.Lighting
		lighting.TimeOfDay = "14:00:00"
		lighting.Brightness = 2
		lighting.ShadowColor = Color3.new(0.5, 0.5, 0.5)
		lighting.Ambient = Color3.new(1, 1, 1)
		lighting.FogEnd = 100000
		lighting.FogColor = Color3.new(1, 1, 1)
	end
]]},
{Text = "S·∫•m S√©t", Script = [[
local Chieucaospwanset = 250
local Taoset_MIN = 10
local Taoset_MAX = 40
local Thoigiantaoset = 0.5
local AREA_RADIUS = 1000
local MIN_SEPARATION = 40
local SEGMENTS = 10
local SEG_THICKNESS_MIN = 0.35
local SEG_THICKNESS_MAX = 1.0
local SEG_REVEAL_TIME_MIN = 0.015
local SEG_REVEAL_TIME_MAX = 0.035
local HOLD_AFTER_HIT = 0.6
local THUNDER_SOUND_IDS = {
	"rbxassetid://118398721483784"
}
local FOLDER_NAME = "PatrickStorm_Spawned"
-- ===================

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer
if not player then return end

-- Helper notify (safe)
local function notify(title, text)
	pcall(function()
		StarterGui:SetCore("SendNotification", {Title = title, Text = text, Duration = 3})
	end)
end

-- cleanup helper
local function cleanupFolder()
	local f = Workspace:FindFirstChild(FOLDER_NAME)
	if f then
		for _, v in ipairs(f:GetChildren()) do
			pcall(function() v:Destroy() end)
		end
		pcall(function() f:Destroy() end)
	end
end

local function getFolder()
	local f = Workspace:FindFirstChild(FOLDER_NAME)
	if not f then
		f = Instance.new("Folder")
		f.Name = FOLDER_NAME
		f.Parent = Workspace
	end
	return f
end

-- Raycast down ignoring player
local function rayToGround(fromPos)
	local rp = RaycastParams.new()
	rp.FilterDescendantsInstances = {player.Character or {}}
	rp.FilterType = Enum.RaycastFilterType.Blacklist
	local res = Workspace:Raycast(fromPos, Vector3.new(0, -10000, 0), rp)
	if res and res.Position then
		return res.Position, res.Instance
	end
	return Vector3.new(fromPos.X, 0, fromPos.Z), nil
end

-- pick start pos high above player, ensure distance from existing list
local function pickFarPosition(centerPos, existing, minDist, maxRadius)
	minDist = minDist or MIN_SEPARATION
	maxRadius = maxRadius or AREA_RADIUS
	for i = 1, 80 do
		local angle = math.random() * math.pi * 2
		local r = math.random(minDist, maxRadius)
		local x = centerPos.X + math.cos(angle) * r
		local z = centerPos.Z + math.sin(angle) * r
		local pos = Vector3.new(x, centerPos.Y + Chieucaospwanset, z)
		local ok = true
		for _, v in ipairs(existing) do
			if (Vector3.new(v.X,0,v.Z) - Vector3.new(pos.X,0,pos.Z)).Magnitude < minDist then
				ok = false; break
			end
		end
		if ok then return pos end
	end
	-- fallback
	local rx = math.random(-maxRadius, maxRadius)
	local rz = math.random(-maxRadius, maxRadius)
	return Vector3.new(centerPos.X + rx, centerPos.Y + Chieucaospwanset, centerPos.Z + rz)
end

-- make a segment part between a and b (hidden initially)
local function makeSegment(a, b, thickness, parent)
	local mid = (a + b) * 0.5
	local dir = b - a
	local len = dir.Magnitude
	local seg = Instance.new("Part")
	seg.Size = Vector3.new(thickness, len, thickness)
	seg.Anchored = true
	seg.CanCollide = false
	seg.Material = Enum.Material.Neon
	seg.Color = Color3.new(1,1,1)
	seg.Transparency = 1
	seg.Parent = parent
	seg.CFrame = CFrame.new(mid, b) * CFrame.Angles(math.rad(90), 0, 0)
	return seg
end

-- spawn one zig-zag bolt built from parts; reveal each segment sequentially so it looks like falling
local function spawnBoltParts(originTop)
	local folder = getFolder()
	local groundPos, hitInst = rayToGround(originTop)

	-- build points
	local points = {}
	for i = 0, SEGMENTS do
		local t = i / SEGMENTS
		local base = originTop:Lerp(groundPos, t)
		local jitterScale = (1 - math.abs(0.5 - t)*2) * 12
		local jitterX = (math.random() - 0.5) * 2 * jitterScale
		local jitterZ = (math.random() - 0.5) * 2 * jitterScale
		points[#points+1] = base + Vector3.new(jitterX, 0, jitterZ)
	end

	-- create segments
	local segments = {}
	for i = 1, #points - 1 do
		local a, b = points[i], points[i+1]
		local thickness = SEG_THICKNESS_MIN + math.random()*(SEG_THICKNESS_MAX - SEG_THICKNESS_MIN)
		local seg = makeSegment(a, b, thickness, folder)
		segments[#segments+1] = seg
	end

	-- reveal segments sequentially
	local revealDelay = SEG_REVEAL_TIME_MIN + math.random()*(SEG_REVEAL_TIME_MAX - SEG_REVEAL_TIME_MIN)
	for i = 1, #segments do
		local seg = segments[i]
		if seg and seg.Parent then
			seg.Transparency = 0
			-- particle sparks
			local pe = Instance.new("ParticleEmitter")
			pe.Speed = NumberRange.new(0)
			pe.Lifetime = NumberRange.new(0.03, 0.12)
			pe.Rate = 80
			pe.Size = NumberSequence.new(0.6)
			pe.LightEmission = 1
			pe.Color = ColorSequence.new(Color3.new(1,1,1), Color3.fromRGB(200,220,255))
			pe.Parent = seg
			Debris:AddItem(pe, 0.45)
		end
		task.wait(revealDelay)
	end

	-- explosion at ground
	local explosion = Instance.new("Explosion")
	explosion.Position = groundPos
	explosion.BlastRadius = 8
	explosion.BlastPressure = 500000
	explosion.ExplosionType = Enum.ExplosionType.NoCraters
	explosion.Parent = Workspace

	-- sound at impact
	local soundPart = Instance.new("Part")
	soundPart.Size = Vector3.new(1,1,1)
	soundPart.Anchored = true
	soundPart.CanCollide = false
	soundPart.Transparency = 1
	soundPart.CFrame = CFrame.new(groundPos)
	soundPart.Parent = folder

	local snd = Instance.new("Sound", soundPart)
	snd.SoundId = THUNDER_SOUND_IDS[math.random(1,#THUNDER_SOUND_IDS)]
	snd.Volume = 3
	snd.RollOffMode = Enum.RollOffMode.Linear
	snd.MaxDistance = 600
	pcall(function() snd:Play() end)
	Debris:AddItem(soundPart, 6)

	local flashPart = Instance.new("Part")
	flashPart.Size = Vector3.new(1,1,1)
	flashPart.Anchored = true
	flashPart.CanCollide = false
	flashPart.Transparency = 1
	flashPart.CFrame = CFrame.new(groundPos)
	flashPart.Parent = folder
	local pl = Instance.new("PointLight", flashPart)
	pl.Color = Color3.fromRGB(255,255,220)
	pl.Range = 70
	pl.Brightness = 8
	Debris:AddItem(flashPart, 1.2)

	-- fade and cleanup
	task.delay(HOLD_AFTER_HIT, function()
		local steps = 10
		for s = 1, steps do
			local t = s / steps
			for _, seg in ipairs(segments) do
				if seg and seg.Parent then seg.Transparency = math.min(1, t) end
			end
			task.wait(0.04)
		end
		for _, seg in ipairs(segments) do pcall(function() seg:Destroy() end) end
	end)
end

-- ========== TOGGLE BEHAVIOR (shared-managed) ==========
-- If a storm loop already exists and is active -> stop it and return.
if shared._PatrickStormLoop and shared._PatrickStormActive then
	-- stop current storm
	pcall(function()
		shared._PatrickStormLoop:Disconnect()
	end)
	shared._PatrickStormLoop = nil
	shared._PatrickStormActive = nil

	-- cleanup visuals & restore lighting if stored
	if shared._PatrickStormSavedLighting then
		local s = shared._PatrickStormSavedLighting
		-- attempt to restore saved lighting values if present
		pcall(function()
			if s.Ambient then Lighting.Ambient = s.Ambient end
			if s.OutdoorAmbient then Lighting.OutdoorAmbient = s.OutdoorAmbient end
			if s.FogStart then Lighting.FogStart = s.FogStart end
			if s.FogEnd then Lighting.FogEnd = s.FogEnd end
			if s.FogColorR and s.FogColorG and s.FogColorB then
				Lighting.FogColor = Color3.new(s.FogColorR, s.FogColorG, s.FogColorB)
			end
			if s.Brightness then Lighting.Brightness = s.Brightness end
			if s.ClockTime then Lighting.ClockTime = s.ClockTime end
			if s.OriginalSky and s.OriginalSky:IsA("Sky") then
				-- restore original sky object back into Lighting
				pcall(function() s.OriginalSky.Parent = Lighting end)
			end
		end)
		shared._PatrickStormSavedLighting = nil
	end

	cleanupFolder()
	notify("PatrickStorm", "S·∫•m S√©t ƒë√£ T·∫ÆT")
	return
end

-- If another loop exists but was left (defensive), clear it first
if shared._PatrickStormLoop then
	pcall(function() shared._PatrickStormLoop:Disconnect() end)
	shared._PatrickStormLoop = nil
	shared._PatrickStormActive = nil
	cleanupFolder()
end

-- Start a new storm loop and register to shared
shared._PatrickStormActive = true

-- Save current lighting so we can restore
if not shared._PatrickStormSavedLighting then
	local s = {}
	pcall(function()
		s.OriginalSky = Lighting:FindFirstChildOfClass("Sky")
		s.Ambient = Lighting.Ambient
		s.OutdoorAmbient = Lighting.OutdoorAmbient
		s.FogStart = Lighting.FogStart
		s.FogEnd = Lighting.FogEnd
		s.FogColorR = Lighting.FogColor.R
		s.FogColorG = Lighting.FogColor.G
		s.FogColorB = Lighting.FogColor.B
		s.Brightness = Lighting.Brightness
		s.ClockTime = Lighting.ClockTime
	end)
	shared._PatrickStormSavedLighting = s
end

-- apply storm lighting (simple)
local StormSky = Instance.new("Sky")
StormSky.Name = "PatrickStorm_Sky"
StormSky.Parent = Lighting
Lighting.Ambient = Color3.fromRGB(70,70,80)
Lighting.OutdoorAmbient = Color3.fromRGB(30,30,40)
Lighting.FogColor = Color3.fromRGB(25,25,30)
Lighting.FogStart = 20
Lighting.FogEnd = 220
Lighting.Brightness = 1.05
Lighting.ClockTime = 18

notify("PatrickStorm", "S·∫•m S√©t ƒë√£ B·∫¨T")

-- spawn loop using RunService.Heartbeat with accumulator so we can disconnect easily
local acc = 0
local conn = RunService.Heartbeat:Connect(function(dt)
	if not shared._PatrickStormActive then
		-- defensive stop
		pcall(function() conn:Disconnect() end)
		shared._PatrickStormLoop = nil
		return
	end

	acc = acc + dt
	if acc < Thoigiantaoset then return end
	acc = acc - Thoigiantaoset

	-- spawn Taoset_MIN..Taoset_MAX bolts this wave
	local char = player.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local count = math.random(Taoset_MIN, Taoset_MAX)
	local chosen = {}
	for i = 1, count do
		local originTop = pickFarPosition(hrp.Position, chosen, MIN_SEPARATION, AREA_RADIUS)
		table.insert(chosen, originTop)
		local stagger = math.random() * 0.1 -- 0..0.1s stagger
		task.delay(stagger, function()
			pcall(function() spawnBoltParts(originTop) end)
		end)
	end
end)

shared._PatrickStormLoop = conn

-- final: notify player
notify("PatrickStorm", "S·∫•m s√©t ƒëang B·∫≠t (" .. tostring(Taoset_MIN) .. "-" .. tostring(Taoset_MAX) .. " m·ªói ƒë·ª£t)")
print("[PatrickStorm] started; use same script to STOP (it toggles).")
]]},
{Text = "Chuy·ªÉn Server Kh√°c", Script = [[
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local success, servers = pcall(function()
    return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100"))
end)

if success then
    local currentJobId = game.JobId
    local possibleServers = {}

    for _, server in pairs(servers.data) do
        if server.id ~= currentJobId and server.playing < server.maxPlayers then
            table.insert(possibleServers, server.id)
        end
    end

    if #possibleServers > 0 then
        local randomServer = possibleServers[math.random(1, #possibleServers)]
        game.StarterGui:SetCore("SendNotification", {
            Title = "Chuy·ªÉn Server",
            Text = "ƒêang chuy·ªÉn ƒë·∫øn server m·ªõi...",
            Duration = 3
        })
        TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer, LocalPlayer)
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Kh√¥ng t√¨m th·∫•y",
            Text = "Kh√¥ng c√≥ server kh√°c kh·∫£ d·ª•ng.",
            Duration = 3
        })
    end
else
    game.StarterGui:SetCore("SendNotification", {
        Title = "L·ªói",
        Text = "Kh√¥ng th·ªÉ t·∫£i danh s√°ch server!",
        Duration = 3
    })
end
]]},
{Text = "Tham gia l·∫°i Server", Script = [[
    local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function notify(msg)
	pcall(function()
		game.StarterGui:SetCore("SendNotification", {
			Title = "Tham Gia L·∫°i Sever",
			Text = msg,
			Duration = 3
		})
	end)
	print("[Rejoin] "..tostring(msg))
end

if not LocalPlayer then
	notify("Kh√¥ng t√¨m th·∫•y LocalPlayer.")
	return
end

local ok, err = pcall(function()
	TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
end)

if ok then
	notify("ƒêang tham gia l·∫°i server hi·ªán t·∫°i...")
else
	notify("Kh√¥ng th·ªÉ rejoin: "..tostring(err))
end
]]},
{Text = "T√¨m Sever √çt Ng∆∞·ªùi", Script = [[
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local currentJobId = game.JobId
local success, response = pcall(function()
    return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
end)

if success then
    local bestServer = nil

    for _, server in pairs(response.data) do
        if server.id ~= currentJobId and server.playing < server.maxPlayers then
            bestServer = server
            break -- server √≠t ng∆∞·ªùi nh·∫•t ƒë·∫ßu ti√™n
        end
    end

    if bestServer then
        game.StarterGui:SetCore("SendNotification", {
            Title = "ƒêang chuy·ªÉn server...",
            Text = "T√¨m th·∫•y server √≠t ng∆∞·ªùi, ƒëang d·ªãch chuy·ªÉn...",
            Duration = 4
        })
        TeleportService:TeleportToPlaceInstance(game.PlaceId, bestServer.id, LocalPlayer)
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Kh√¥ng t√¨m th·∫•y",
            Text = "Kh√¥ng c√≥ server n√†o kh√°c kh·∫£ d·ª•ng.",
            Duration = 4
        })
    end
else
    game.StarterGui:SetCore("SendNotification", {
        Title = "L·ªói",
        Text = "Kh√¥ng th·ªÉ t·∫£i danh s√°ch server!",
        Duration = 4
    })
end
]]},
}

local TextService = game:GetService("TextService")

local paddingX = 10
local paddingY = 10
local spacingX = 10
local spacingY = 10

local function createButtons()
    for _, child in ipairs(Content:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end

    local xOffset, yOffset = 0, 0
    local contentWidth = Content.AbsoluteSize.X

    for i, v in ipairs(scripts) do
        local textSize = TextService:GetTextSize(v.Text, 24, Enum.Font.SourceSansBold, Vector2.new(math.huge, math.huge))
        local btnW = textSize.X + paddingX * 3
        local btnH = textSize.Y + paddingY * 1

        if xOffset + btnW > contentWidth then
            xOffset = 0
            yOffset = yOffset + btnH + spacingY
        end

        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0, btnW, 0, btnH)
        btn.Position = UDim2.new(0.01, xOffset, 0.01, yOffset)
        btn.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        btn.BorderColor3 = Color3.new(0, 0, 0)
        btn.BorderSizePixel = 2
        btn.Font = Enum.Font.SourceSansBold
        btn.TextSize = 24
        btn.Text = v.Text
        btn.TextColor3 = Color3.new(0, 0, 0)
        btn.TextScaled = false
        btn.Parent = Content

        btn.MouseButton1Click:Connect(function()
            pcall(function() loadstring(v.Script)() end)
        end)

        xOffset = xOffset + btnW + spacingX
    end
end

Content:GetPropertyChangedSignal("AbsoluteSize"):Connect(createButtons)

createButtons()
